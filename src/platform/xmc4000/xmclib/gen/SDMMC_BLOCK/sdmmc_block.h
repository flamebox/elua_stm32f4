
/**
 * @file sdmmc_block.h
 * @date 2016-04-05
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * SDMMC_BLOCK v4.0.8 - The SDMMC_BLOCK APP is a generic SD/MMC card block device driver designed to drive SDMMC cards
 *                      with all relevant functionalities like writing or reading blocks of data from the card.
 *
 * Copyright (c) 2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2016-01-20:
 *     - Initial version. <br>
 *
 * 2016-02-05:
 *     - RTOS support added. <br>
 *     - Bug fixes done.<br>
 *
 * 2016-02-08:
 *     - Help Doc updated. <br>
 *     - Bug fixes done.<br>
 *
 * 2016-04-05:
 *     - Remove dead code <br>
 *     - MISRA fixes <br>
 *
 * @endcond
 */

#ifndef SDMMC_BLOCK_H
#define SDMMC_BLOCK_H

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include "sdmmc_block_conf.h"
#include "xmc_gpio.h"
#include "DAVE_common.h"

#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 1U) && \
       (XMC_LIB_PATCH_VERSION >= 4U)))
#error "SDMMC_BLOCK requires XMC Peripheral Library v2.1.4 or higher"
#endif

/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

#define SDMMC_BLOCK_NORMAL_INT_STATUS_BITS         (0x7FFFU) /**< Normal interrupt status bits */
#define SDMMC_BLOCK_BLOCK_ADDRESSING               (8U) /**< Card supports block addressing. It means address will be
                                                             taken in terms of sector numbers */

#define SDMMC_BLOCK_IN_IDLE_STATE                  (0x01U) /**< Idle State */
#define SDMMC_BLOCK_ILLEGAL_COMMAND                (0x04U) /**< Illegal Command */

/**< Some Command's static Arguments */
#define SDMMC_BLOCK_ARGUMENT0                      (0x00000000U)
#define SDMMC_BLOCK_SD_CMD8_ARG                    (0x000001AAU)
#define SDMMC_BLOCK_SD_ACMD41_F80_ARG              (0x00100000U)
#define SDMMC_BLOCK_SD_ACMD41_F81_ARG              (0x40100000U)
#define SDMMC_BLOCK_MMC_CMD1_ARG                   (0x40FF8000U)
#define SDMMC_BLOCK_MMC_4BUS_WIDTH_ARG             (0x03B70100U)
#define SDMMC_BLOCK_SD_4BUS_WIDTH_ARG              (0x00000002U)
#define SDMMC_BLOCK_MMC_HIGH_SPEED_ARG             (0x03B90100U)
#define SDMMC_BLOCK_SD_HIGH_SPEED_ARG              (0x80000001U)

/**< RCA Register */
#define SDMMC_BLOCK_MMC_DEFAULT_RCA                (0x0001U)
#define SDMMC_BLOCK_ARG_RCA_BITPOS                 (0x10U)

#define SDMMC_BLOCK_SD_CARD_TYPE_BITMASK           (0xFFFFU) /**< Card type mask */

/* SCR Register Bitmask */
#define SDMMC_BLOCK_SCR_BUS_WIDTH4_BITMASK         (0x4U) /**< Bus width mask */

/**<  SD Card's CMD8 response R7 bit positions */
#define SDMMC_BLOCK_SD_CMD8_CHECK_PATTERN_VALUE    (0xAAU)
#define SDMMC_BLOCK_SD_CMD8_CHECK_PATTERN_BITMASK  (0xFFU)
#define SDMMC_BLOCK_SD_CMD8_CHECK_PATTERN_BITPOS   (0x00U)
#define SDMMC_BLOCK_SD_CMD8_VHS_BITPOS             (0x8U)
#define SDMMC_BLOCK_SD_CMD8_VHS_BITMASK            (0xFU)
#define SDMMC_BLOCK_SD_VHS_PATTERN_2_7_3_6_VALUE   (0x1U)

/**< Card's OCR register  */
#define SDMMC_BLOCK_OCR_POWER_STATUS_BITMASK       (0x80000000U)
#define SDMMC_BLOCK_OCR_CCS_BITMASK                (0x40000000U)
#define SDMMC_BLOCK_MMC_OCR_ACCESS_MODE_BITMASK    (0x60000000U)
#define SDMMC_BLOCK_MMC_OCR_ACCESS_MODE_BITPOS     (0x1DU)

/*
 * Command code for disk_ioctrl function
 */

/* Generic command (defined for FatFs) */
#define SDMMC_BLOCK_CTRL_SYNC                      (0U) /**< Flush disk cache (for write functions) */
#define SDMMC_BLOCK_GET_SECTOR_COUNT               (1U) /**< Get media size */
#define SDMMC_BLOCK_GET_SECTOR_SIZE                (2U) /**< Get sector size */
#define SDMMC_BLOCK_GET_BLOCK_SIZE                 (3U) /**< Get erase block size */
#define SDMMC_BLOCK_CTRL_TRIM                      (4U) /**< Inform device that the data on the block of sectors is
                                                             no longer used. */

/* Generic command */
#define SDMMC_BLOCK_CTRL_EJECT                     (7U) /**< Eject media */

/* MMC/SDC specific ioctl command */
#define SDMMC_BLOCK_MMC_GET_TYPE                   (10U) /**< Get card type i.e. Standard Capacity v2/v1x or
                                                              High Capacity card. */
#define SDMMC_BLOCK_MMC_GET_CSD                    (11U) /**< Get Card's Specific Data register */
#define SDMMC_BLOCK_MMC_GET_CID                    (12U) /**< Get Card's Identification register */
#define SDMMC_BLOCK_MMC_GET_OCR                    (13U) /**< Get Card's Operating Condition Register  */
#define SDMMC_BLOCK_MMC_GET_SDSTAT                 (14U) /**< Get SD card status information.  */

/*
 * NAND specific ioctl command
 */

/* Create physical format */
#define SDMMC_BLOCK_NAND_FORMAT                    (30U)
#define SDMMC_BLOCK_MMC_LOCK_CARD                  (31U) /**< Locks the card. */
#define SDMMC_BLOCK_MMC_UNLOCK_CARD                (32U) /**< Unlocks the card. */
#define SDMMC_BLOCK_MMC_SET_PASSWD                 (33U) /**< Set/replace the password. */
#define SDMMC_BLOCK_MMC_CLEAR_PASSWD               (34U) /**< Clears the password. */
#define SDMMC_BLOCK_MMC_SET_LOCK                   (35U) /**< Sets the password and locks the card,
                                                              in the same power cycle. */
#define SDMMC_BLOCK_MMC_READ_LOCK_STATUS           (36U) /**< Reads the current lock status of the card. */
#define SDMMC_BLOCK_MMC_FORCE_ERASE                (37U) /**< Force erase the password. It is useful when user forgets
                                                              the password. */

#define SDMMC_BLOCK_MAX_PASSWORD_LENGTH            (16U) /* Max. password length: lock/unlock */

/**********************************************************************************************************************
 * ENUMERATIONS
 **********************************************************************************************************************/
/**
 * @ingroup SDMMC_BLOCK_enumerations
 * @{
 */

/**
 * @brief Return status of SDMMC_BLOCK APP functions
 */
typedef enum SDMMC_BLOCK_MODE_STATUS
{
  SDMMC_BLOCK_MODE_STATUS_SUCCESS = 0U,          /**< Success */
  SDMMC_BLOCK_MODE_STATUS_FAILURE,               /**< Failure */
  SDMMC_BLOCK_MODE_STATUS_COMMAND_TIMEOUT_ERROR, /**< Timeout error */
  SDMMC_BLOCK_MODE_STATUS_COMMAND_CRC_ERROR,     /**< CRC error */
  SDMMC_BLOCK_MODE_STATUS_COMMAND_ENDBIT_ERROR,  /**< End bit error */
  SDMMC_BLOCK_MODE_STATUS_COMMAND_INDEX_ERROR,   /**< Command index error */
  SDMMC_BLOCK_MODE_STATUS_DATA_TIMEOUT_ERROR,    /**< Data timeout error */
  SDMMC_BLOCK_MODE_STATUS_DATA_CRC_ERROR,        /**< Data CRC error */
  SDMMC_BLOCK_MODE_STATUS_DATA_ENDBIT_ERROR,     /**< Data end-bit error */
  SDMMC_BLOCK_MODE_STATUS_ACMD12_ERROR,          /**< ACMD12 error */
  SDMMC_BLOCK_MODE_STATUS_OUT_OF_RANGE_ERROR,    /**< Out of range error */
  SDMMC_BLOCK_MODE_STATUS_ADDRESS_ERROR,         /**< Address error */
  SDMMC_BLOCK_MODE_STATUS_BLOCK_LEN_ERROR,       /**< Length error */
  SDMMC_BLOCK_MODE_STATUS_ERASE_SEQ_ERROR,       /**< Sequence error */
  SDMMC_BLOCK_MODE_STATUS_ERASE_PARAM_ERROR,     /**< Erase parameter error */
  SDMMC_BLOCK_MODE_STATUS_WP_VIOLATION_ERROR,    /**< Write protect violation error */
  SDMMC_BLOCK_MODE_STATUS_LOCK_UNLOCK_ERROR,     /**< Lock/Unlock error */
  SDMMC_BLOCK_MODE_STATUS_COM_CRC_ERROR,         /**< Command CRC error */
  SDMMC_BLOCK_MODE_STATUS_ILLEGAL_COMMAND_ERROR, /**< Illegal command error */
  SDMMC_BLOCK_MODE_STATUS_CARD_ECC_ERROR,        /**< ECC error */
  SDMMC_BLOCK_MODE_STATUS_CC_ERROR,              /**< CC error */
  SDMMC_BLOCK_MODE_STATUS_UNKNOWN_ERROR,         /**< Unknown error */
  SDMMC_BLOCK_MODE_STATUS_CSD_OVERWRITE,         /**< CSD overwrite */
  SDMMC_BLOCK_MODE_STATUS_WP_ERASE_SKIP_ERROR,   /**< Write protect erase skip error */
  SDMMC_BLOCK_MODE_STATUS_ASK_SEQ_ERROR,         /**< Ask sequence error */
  SDMMC_BLOCK_MODE_STATUS_BAD_RESPONSE,          /**< Bad response */
  SDMMC_BLOCK_MODE_STATUS_CMD_LINE_BUSY,         /**< Command line busy */
  SDMMC_BLOCK_MODE_STATUS_DATA_LINE_BUSY,        /**< Data line busy */
  SDMMC_BLOCK_MODE_STATUS_COMMAND_COMPLETE,      /**< Command complete */
  SDMMC_BLOCK_MODE_STATUS_SENDCOMMAND_ERROR,     /**< Send command error */
  SDMMC_BLOCK_MODE_STATUS_BUFFER_READY,          /**< Buffer ready */
  SDMMC_BLOCK_MODE_STATUS_TRANSFER_COMPLETE,     /**< Transfer complete */
  SDMMC_BLOCK_MODE_STATUS_CARD_IS_LOCKED,        /**< Card is locked */
  SDMMC_BLOCK_MODE_STATUS_CARD_UNLOCKED,         /**< Card unlocked */
  SDMMC_BLOCK_MODE_STATUS_READ_ERROR,            /**< Read error */
  SDMMC_BLOCK_MODE_STATUS_WRITE_ERROR,           /**< Write error */
  SDMMC_BLOCK_MODE_STATUS_RECOVERABLE_ERROR,     /**< Recoverable error */
  SDMMC_BLOCK_MODE_STATUS_NONRECOVERABLE_ERROR,  /**< Non-recoverable error */
  SDMMC_BLOCK_MODE_STATUS_ACMD_CMD_WO_DAT_ERROR, /**< Command without data error */
  SDMMC_BLOCK_MODE_STATUS_ACMD_BOTH_ERROR,       /**< ACMD both error */
  SDMMC_BLOCK_MODE_STATUS_ACMD_SD_TRANSFER_ERROR, /**< ACMD SD transfer error */
  SDMMC_BLOCK_MODE_STATUS_ACMD_CMD_WO_DAT_NOT_ISSUED, /**< Command without data not issued */
  SDMMC_BLOCK_MODE_STATUS_INIT_FAIL,             /**< Init failed */
  SDMMC_BLOCK_MODE_STATUS_INITIALIZED_BUT_LOCKED, /**< Initialized but locked */
  SDMMC_BLOCK_MODE_STATUS_HOST_CONTROLLER_INITIALIZED, /**< Host controller initialized */
  SDMMC_BLOCK_MODE_STATUS_NULL_POINTER,          /**< NULL pointer */
  SDMMC_BLOCK_MODE_STATUS_TIMEOUT_OCCURED,       /**< Timeout occured */
  SDMMC_BLOCK_MODE_STATUS_CREATE_TIMER_FAILED,   /**< Create timer failed */
  SDMMC_BLOCK_MODE_STATUS_DELETE_TIMER_FAILED,   /**< Delete timer failed */
  SDMMC_BLOCK_MODE_STATUS_START_TIMER_FAILED,    /**< Start timer failed */
  SDMMC_BLOCK_MODE_STATUS_STOP_TIMER_FAILED,     /**< Stop timer failed */
  SDMMC_BLOCK_MODE_STATUS_SECTOR_OUT_OF_BOUND,   /**< Sector out of bound */
  SDMMC_BLOCK_MODE_STATUS_VOLTAGE_ERROR,         /**< Voltage error */
  SDMMC_BLOCK_MODE_STATUS_PATTERN_ERROR,         /**< Pattern error */
  SDMMC_BLOCK_MODE_STATUS_COMMUNICATION_ERROR    /**< Communication error */
} SDMMC_BLOCK_MODE_STATUS_t;

/**
 * @brief SDMMC_BLOCK status
 */
typedef enum SDMMC_BLOCK_STATUS
{
  SDMMC_BLOCK_STATUS_SUCCESS = 0U, /**< Success */
  SDMMC_BLOCK_STATUS_FAILURE,      /**< Failure */
  SDMMC_BLOCK_STATUS_WRPRT,        /**< Write protected */
  SDMMC_BLOCK_STATUS_NOTRDY,       /**< Not ready */
  SDMMC_BLOCK_STATUS_PARERR,       /**< Parameter error */
  SDMMC_BLOCK_STATUS_LOCKED        /**< Locked */
} SDMMC_BLOCK_STATUS_t;

/**
 * @brief Card lock/unlock
 */
typedef enum SDMMC_BLOCK_CARD_LOCK_STATUS
{
  SDMMC_BLOCK_CARD_LOCK_STATUS_UNLOCKED = 0U, /**< Card is not locked */
  SDMMC_BLOCK_CARD_LOCK_STATUS_LOCKED         /**< Card is locked */
} SDMMC_BLOCK_CARD_LOCK_STATUS_t;

/**
 * @brief Card types
 */
typedef enum SDMMC_BLOCK_CARD_TYPE
{
  SDMMC_BLOCK_CARD_TYPE_STANDARD_CAPACITY_V2  = 1U, /**< Capacity V2 */
  SDMMC_BLOCK_CARD_TYPE_STANDARD_CAPACITY_V1X = 2U, /**< Capacity V1X */
  SDMMC_BLOCK_CARD_TYPE_HIGH_CAPACITY         = 4U, /**< High capacity */
  SDMMC_BLOCK_CARD_TYPE_BLOCK_ADDRESSING      = 8U, /**< Block addressing */
  SDMMC_BLOCK_CARD_TYPE_MMC                   = 16U /**< MMC type */
} SDMMC_BLOCK_CARD_TYPE_t;

/**
 * @brief Card states
 */
typedef enum SDMMC_BLOCK_CARD_STATE
{
  SDMMC_BLOCK_CARD_STATE_INITIALIZED     = 0U,  /**< Card initialized */
  SDMMC_BLOCK_CARD_STATE_NOT_INITIALIZED = 1U,  /**< Card initialized */
  SDMMC_BLOCK_CARD_STATE_NO_CARD         = 2U,  /**< No card available */
  SDMMC_BLOCK_CARD_STATE_WRITE_PROTECTED = 4U,  /**< Card write protected */
  SDMMC_BLOCK_CARD_STATE_LOCKED          = 8U,  /**< Card locked */
  SDMMC_BLOCK_CARD_STATE_CMD_ACTIVE      = 16U, /**< Command line in use */
  SDMMC_BLOCK_CARD_STATE_DATA_ACTIVE     = 32U, /**< Data line in use */
  SDMMC_BLOCK_CARD_STATE_HC_INITIALIZED  = 64U  /**< Host controller initialized */
} SDMMC_BLOCK_CARD_STATE_t;

/**
 * @brief Card types
 */
typedef enum SDMMC_BLOCK_CARD_CAPACITY
{
  SDMMC_BLOCK_CARD_CAPACITY_UNKNOWN  = 0U, /**< Unknown */
  SDMMC_BLOCK_CARD_CAPACITY_MMC      = 1U, /**< MMC */
  SDMMC_BLOCK_CARD_CAPACITY_SD       = 2U, /**< SD */
  SDMMC_BLOCK_CARD_CAPACITY_SDHC     = 3U  /**< SDHC */
} SDMMC_BLOCK_CARD_CAPACITY_t;

/**
 * @brief Card interface (SPI OR native SD?)
 */
typedef enum SDMMC_BLOCK_CARD_INTERFACE
{
  SDMMC_BLOCK_CARD_INTERFACE_SD  = 0U, /**< SD interface */
  SDMMC_BLOCK_CARD_INTERFACE_SPI = 1U  /**< SPI interface */
} SDMMC_BLOCK_CARD_INTERFACE_t;

/**
 * @brief RTOS mode
 */
typedef enum SDMMC_BLOCK_RTOS_MODE
{
  SDMMC_BLOCK_RTOS_MODE_DISABLED  = 0U, /**< RTOS mode is not selected */
  SDMMC_BLOCK_RTOS_MODE_ENABLED = 1U  /**< RTOS mode is selected */
} SDMMC_BLOCK_RTOS_MODE_t;

#ifdef SDMMC_BLOCK_SD

/**
 * @brief This enumerates some of the SDMMC interrupts
 */
typedef enum SDMMC_BLOCK_SD_INTERRUPT
{
  SDMMC_BLOCK_SD_INTERRUPT_CARD_REMOVAL = 0U, /**< Card removal interrupt */
  SDMMC_BLOCK_SD_INTERRUPT_CARD_INSERTION     /**< Card insertion interrupt */
} SDMMC_BLOCK_SD_INTERRUPT_t;

/**
 * @brief Data transfer direction
 */
typedef enum SDMMC_BLOCK_SD_DATA_TRANSFER
{
  SDMMC_BLOCK_SD_DATA_TRANSFER_READ_BUFFER = 1U, /**< Read from card */
  SDMMC_BLOCK_SD_DATA_TRANSFER_WRITE_BUFFER      /**< Write to card */
} SDMMC_BLOCK_SD_DATA_TRANSFER_t;

#endif

typedef void (*SDMMC_BLOCK_Config_Init)(void);

/**
 * @}
 */
/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/

/**
 * @ingroup SDMMC_BLOCK_datastructures
 * @{
 */

/**
 * @brief This structure stores the SD Card's SCR register content.
 */
typedef struct SDMMC_BLOCK_SCR
{
  uint32_t sd_spec         : 4; /**< Physical Layer Specification Version supported by the card */
  uint32_t scr_structure   : 4; /**< SCR version */
  uint32_t sd_bus_width    : 4; /**< DAT bus widths that are supported by card */
  uint32_t sd_security     : 3; /**< CPRM security specification version for each capacity card */
  uint32_t data_erase_stat : 1; /**< Data status after erase (0 or 1) */
  uint32_t                 : 3; /**< Reserved bits */
  uint32_t ext_security    : 4; /**< Extended security */
  uint32_t sd_spec_3       : 1; /**< SD specification version */
  uint32_t cmd_support     : 2; /**< Support bit of new commands are defined to bit 33-32 of SCR */
  uint32_t                 : 6; /**< Reserved bits */
  uint32_t manuf_resvd     : 32; /**< Reserved: Manufacturer's use */
} SDMMC_BLOCK_SCR_t;

/**
 * @brief Stores SD card CID register content
 */
typedef struct SDMMC_BLOCK_CID
{
  uint16_t manufacturing_date; /**< 12 bit Manufacturing date (MDT) */
  uint32_t product_serial_num; /**< 32 bit serial number (PSN) */
  uint8_t  product_rev;        /**< 32 bit Product revision (PRV) */
  uint8_t  product_name[5];    /**< 40 bit product name (PNM) */
  uint8_t  app_oem_id[2];      /**< 16 bit OEM/Application ID (OID) */
  uint8_t  manufacturer_id;    /**< 8 bit Manufacturer ID (MID) */
} SDMMC_BLOCK_CID_t;

/**
 * @brief Stores SD (v1) card's CSD register content
 */
typedef struct SDMMC_BLOCK_SDV1_CSD
{
  uint32_t fixed               : 1; /**< Always fixed to 1 */
  uint32_t crc                 : 7; /**< CRC bits */
  uint32_t                     : 2; /**< Reserved bits */
  uint32_t file_fmt            : 2; /**< Indicates file format on the card */
  uint32_t temp_write_prot     : 1; /**< Temporarily protects card content from being overwritten or erased */
  uint32_t perm_write_prot     : 1; /**< Permanently protects card content against overwriting or erasing */
  uint32_t copy                : 1; /**< Defines if content is original (= 0) or has been copied (= 1) */
  uint32_t file_fmt_grp        : 1; /**< Indicates selected group of file formats */
  uint32_t                     : 5; /**< Reserved bits */
  uint32_t write_blk_partial   : 1; /**< Defines if partial block sizes can be used in block write commands */
  uint32_t write_blk_len       : 4; /**< Maximum write data block length is computed as 2WRITE_BL_LEN */
  uint32_t write_speed_factor  : 3; /**< Defines typical block program time as a multiple of the read access time */
  uint32_t                     : 2; /**< Reserved bits */
  uint32_t write_prot_grp_en   : 1; /**< A value of 0 means no group write protection possible */
  uint32_t write_prot_grp_size : 7; /**< Size of a write protected group; Indexed from 0 */
  uint32_t erase_sector_size   : 7; /**< Size of an erasable sector */
  uint32_t erase_blk_en        : 1; /**< ERASE_BLK_EN defines granularity of unit size of erasable data */
  uint32_t dev_size_mult       : 3; /**< Multiplier for total size of device (Check C_SIZE) */
  uint32_t max_write_current   : 3; /**< Maximum write current at maximum VDD */
  uint32_t min_write_current   : 3; /**< Maximum write current at minimum VDD */
  uint32_t max_read_current    : 3; /**< Maximum read current at maximum VDD */
  uint32_t min_read_current    : 3; /**< Maximum read current at minimum VDD */
  uint32_t dev_size_low        : 2; /**< Total size of data card */
  uint32_t dev_size_high       : 10;/**< Total size of data card */
  uint32_t                     : 2; /**< Reserved bits */
  uint32_t dsr_imp             : 1; /**< Is configurable driver stage is integrated with card? */
  uint32_t read_blk_misalign   : 1; /**< Can read block occupy more than 1 physical block on card? */
  uint32_t write_blk_misalign  : 1; /**< Can written block occupy more than 1 physical block on card? */
  uint32_t read_blk_partial    : 1; /**< Can a block be read partially? : Always valid in SD */
  uint32_t read_blk_len        : 4; /**< Maximum read data block length is computed as 2READ_BL_LEN */
  uint32_t ccc                 : 12; /**< Card command class register specifies supported command classes */
  uint32_t tran_speed          : 8; /**< Defines maximum data transfer rate per one data line */
  uint32_t nsac                : 8; /**< Defines worst case for clock-dependent factor of the data access time */
  uint32_t taac                : 8; /**< Defines asynchronous part of data access time */
  uint32_t                     : 6; /**< Reserved bits */
  uint32_t csd_struct          : 2; /**< Describes version of the CSD structure */
} SDMMC_BLOCK_SDV1_CSD_t;

/**
 * @brief Stores SD (v2) card's CSD register content
 */
typedef struct SDMMC_BLOCK_SDV2_CSD
{
  uint32_t fixed               : 1; /**< Always fixed to 1 */
  uint32_t crc                 : 7; /**< CRC bits */
  uint32_t                     : 2; /**< Reserved bits */
  uint32_t file_fmt            : 2; /**< Indicates file format on the card */
  uint32_t temp_write_prot     : 1; /**< Temporarily protects card content from being overwritten or erased */
  uint32_t perm_write_prot     : 1; /**< Permanently protects card content against overwriting or erasing */
  uint32_t copy                : 1; /**< Defines if content is original (= 0) or has been copied (= 1) */
  uint32_t file_fmt_grp        : 1; /**< Indicates selected group of file formats */
  uint32_t                     : 5; /**< Reserved bits */
  uint32_t write_blk_partial   : 1; /**< Defines if partial block sizes can be used in block write commands */
  uint32_t write_blk_len       : 4; /**< Maximum write data block length is computed as 2WRITE_BL_LEN */
  uint32_t write_speed_factor  : 3; /**< Defines typical block program time as a multiple of the read access time */
  uint32_t                     : 2; /**< Reserved bits */
  uint32_t write_prot_grp_en   : 1; /**< A value of 0 means no group write protection possible */
  uint32_t write_prot_grp_size : 7; /**< Size of a write protected group; Indexed from 0 */
  uint32_t erase_sector_size   : 7; /**< Size of an erasable sector */
  uint32_t erase_blk_en        : 1; /**< If 1, host can erase one or multiple units of 512 bytes */
  uint32_t                     : 1; /**< Reserved bits */
  uint32_t dev_size_low        : 16;/**< Total size of data card */
  uint32_t dev_size_high       : 6; /**< Total size of data card */
  uint32_t                     : 6; /**< Reserved bits */
  uint32_t dsr_imp             : 1; /**< Is configurable driver stage is integrated with card? */
  uint32_t read_blk_misalign   : 1; /**< When 0, read crossing block boundaries is disabled in high capacity SD cards */
  uint32_t write_blk_misalign  : 1; /**< When 0, write crossing block boundaries is disabled in high capacity SD cards*/
  uint32_t read_blk_partial    : 1; /**< Fixed to 0; Only unit of block access is permitted */
  uint32_t read_blk_len        : 4; /**< Fixed at 0x09; Indicates READ_BL_LEN = 512 bytes */
  uint32_t ccc                 : 12; /**< Card command class register specifies supported command classes */
  uint32_t tran_speed          : 8; /**< Defines maximum data transfer rate per one data line */
  uint32_t nsac                : 8; /**< Fixed at 0x00 */
  uint32_t taac                : 8; /**< Fixed at 0x0E; Indicates asynchronous part of data access time as 1 ms */
  uint32_t                     : 6; /**< Reserved bits */
  uint32_t csd_struct          : 2; /**< Describes version of the CSD structure */
} SDMMC_BLOCK_SDV2_CSD_t;

/**
 * @brief SDMMC_BLOCK GPIO configuration
 */
typedef struct SDMMC_BLOCK_GPIO_CONFIG
{
  XMC_GPIO_CONFIG_t config; /**< Pin configuration structure */
  XMC_GPIO_HWCTRL_t hw_control; /**< HW control setting for pins */
} SDMMC_BLOCK_GPIO_CONFIG_t;

/**
 * @brief SDMMC pin configuration
 */
typedef struct SDMMC_BLOCK_PIN_CONFIG
{
  XMC_GPIO_PORT_t *const port;             /**< Pointer to the GPIO port base address */
  const uint8_t pin;                       /**< Pin number in the port */
  const SDMMC_BLOCK_GPIO_CONFIG_t *config; /**< Reference to pin configuration structure */
} SDMMC_BLOCK_PIN_CONFIG_t;

#if SDMMC_BLOCK_RTOS_MODE_SELECT

/**
 * @brief Resources for SDMMC RTOS mode
 */
typedef struct SDMMC_BLOCK_CMSIS_RTOS
{
  uint32_t os_mutex_cb_cmd_mut_handle[4];     /**< Command mutex handle */
  osMutexDef_t os_mutex_def_cmd_mut_handle;   /**< Command mutex definition */
  osMutexId cmd_mut_id;                       /**< Command mutex id */

  uint32_t os_mutex_cb_data_mut_handle[4];    /**< Data mutex handle */
  const osMutexDef_t os_mutex_def_data_mut_handle; /**< Data mutex definition */
  osMutexId data_mut_id;                      /**< Data mutex id */

  uint32_t os_semaphore_cb_cmd_sem[2];        /**< Semaphore for commands */
  const osSemaphoreDef_t os_semaphore_def_cmd_sem; /**< Command semaphore definition */
  osSemaphoreId cmd_sem_id;                   /**< Command semaphore id */
  int32_t cmd_sem_index;                     /**< Command semaphore index */

  uint32_t os_semaphore_cb_data_sem[2];       /**< Semaphore for data */
  const osSemaphoreDef_t os_semaphore_def_data_sem; /**< Data semaphore definition */
  osSemaphoreId data_sem_id;                  /**< Data semaphore id */
  int32_t data_sem_index;                    /**< Data semaphore index */

#ifdef SDMMC_BLOCK_SD
  uint32_t os_semaphore_cb_transfer_sem[2];   /**< Semaphore for transfer */
  const osSemaphoreDef_t os_semaphore_def_transfer_sem; /**< Transfer semaphore definition */
  osSemaphoreId transfer_sem_id;              /**< Transfer semaphore id */
  int32_t transfer_sem_index;                /**< Transfer semaphore index */
#endif

#ifdef SDMMC_BLOCK_SPI
  uint32_t os_mutex_cb_init_mut_handle[4];     /**< Command mutex handle */
  osMutexDef_t os_mutex_def_init_mut_handle;   /**< Command mutex definition */
  osMutexId init_mut_id;                       /**< Command mutex id */
#endif

  bool os_resources_created;                  /**< Semaphore and mutex created successfully */
} SDMMC_BLOCK_CMSIS_RTOS_t;

#endif /* #if SDMMC_BLOCK_RTOS_MODE_SELECT */

#ifdef SDMMC_BLOCK_SPI
/**
 * @brief This structure stores the card's register content information
 */
typedef struct SDMMC_BLOCK_SPI_CARD_INFORMATION
{
  uint8_t ocr[4];        /**< OCR register contents */
  uint8_t cid[16];       /**< CID register contents */
  uint8_t csd[16];       /**< CSD register contents */
  SDMMC_BLOCK_SCR_t scr; /**< SCR register content */
  uint8_t sd_status[64]; /**< SD_STATUS */
} SDMMC_BLOCK_SPI_CARD_INFORMATION_t;

/**
 * @brief configuration in SPI mode
 */
typedef struct SDMMC_BLOCK_SPI
{
  SPI_MASTER_t *spi_master_handle;              /**< Pointer to the SPI_MASTER configuration handler */
  SDMMC_BLOCK_SPI_CARD_INFORMATION_t card_info; /**< Card information */
#if SDMMC_BLOCK_RTOS_MODE_SELECT
  SDMMC_BLOCK_CMSIS_RTOS_t *rtos;               /**< Resources specific to RTOS mode */
#endif
  uint8_t cmd_response;                         /**< Command response value */
  bool mode_init_flag;                          /**< Flag indicating initialization return value */
} SDMMC_BLOCK_SPI_t;

#endif

#ifdef SDMMC_BLOCK_SD

/**
 * @brief This structure stores the card's register content information
 */
typedef struct SDMMC_BLOCK_SD_CARD_INFORMATION
{
  uint32_t ocr;          /**< OCR register contents */
  uint32_t cid[4];       /**< CID register contents */
  uint32_t csd[4];       /**< CSD register contents */
  SDMMC_BLOCK_SCR_t scr; /**< SCR register contents */
  uint16_t rca;          /**< Card's relative address */
} SDMMC_BLOCK_SD_CARD_INFORMATION_t;

/**
 * @brief This structure stores the Interrupt Context Information.
 */
typedef struct SDMMC_BLOCK_INTERRUPT_CONTEXT
{
  uint16_t int_status_shadow; /**< Stores interrupt status register status bits */
  uint8_t  cmd_flag;          /**< Set when command specific interrupt occurs */
  uint8_t  data_flag;         /**< Set when data transfer error interrupt occurs */
  uint8_t  transfer_flag;     /**< Set when transfer complete interrupt occurs */
} SDMMC_BLOCK_INTERRUPT_CONTEXT_t;

/**
 * @brief configuration in SD mode
 */
typedef struct SDMMC_BLOCK_SD
{
  XMC_SDMMC_t *sdmmc;                           /**< Base SDMMC pointer */
  SDMMC_BLOCK_INTERRUPT_CONTEXT_t isr_context;  /**< Interrupt context */
  uint32_t int_priority;                        /**< Interrupt priority */
  uint32_t int_sub_priority;                    /**< Interrupt sub-priority */
  uint32_t buf_ready_int;                       /**< Buffer ready interrupt */
  SDMMC_BLOCK_MODE_STATUS_t data_int_err;       /**< Interrupt error in data transfer */
  SDMMC_BLOCK_MODE_STATUS_t cmd_int_err;        /**< Interrupt error in cmd issuance */
  SDMMC_BLOCK_MODE_STATUS_t transfer_int_err;   /**< Interrupt status if transfer successful */
  SDMMC_BLOCK_MODE_STATUS_t acmd_int_err;       /**< Interrupt status in issuance of ACMD12 Command */
  SDMMC_BLOCK_MODE_STATUS_t err_recovery_stat;  /**< Error recovery status of a failed transaction */
#if SDMMC_BLOCK_SD_CARD_DETECTION_SUPPORT
  void (*callback)(SDMMC_BLOCK_SD_INTERRUPT_t); /**< call-back function */
#endif
  SDMMC_BLOCK_SD_CARD_INFORMATION_t card_info;  /**< Card information */
  uint8_t f8;                                   /**< Flag used in card initialization to identify card type */
  uint8_t issue_abort;                          /**< Issue abort */
#if !SDMMC_BLOCK_RTOS_MODE_SELECT
  volatile uint32_t tmr_id;                     /**< SYSTIMER identifier */
  SYSTIMER_t *systimer;                         /**< SYSTIMER instance */
#endif
  volatile bool tmr_expire;                     /**< Timeout (expiration) flag */
  XMC_SDMMC_DATA_LINES_t bus_width;             /**< Bus width */
  bool mode_init_flag;                          /**< Flag indicating initialization return value */
#if SDMMC_BLOCK_RTOS_MODE_SELECT
  uint32_t *buf;                                /**< Data buffer */
  uint32_t block_count;                         /**< Block count */
  uint32_t transfer_quad_bytes;                 /**< Number of quad bytes to transfer */
  SDMMC_BLOCK_CMSIS_RTOS_t *rtos;               /**< Resources specific to RTOS mode */
#endif

} SDMMC_BLOCK_SD_t;

#endif

/**
 * @brief Store local lock structure information
 */
typedef struct SDMMC_BLOCK_LOCK_STRUCTURE
{
  uint8_t mode;        /**< 8-bit card lock/unlock mode */
  uint8_t pwd_len;     /**< Password length; Also the length of new and old passwords in case of change */
  uint8_t pwd_data[SDMMC_BLOCK_MAX_PASSWORD_LENGTH * 2U]; /**< New password OR old + new in case of change */
} SDMMC_BLOCK_LOCK_STRUCTURE_t;

/**
 * @brief Password structure
 */
typedef struct SDMMC_BLOCK_PASSWORD
{
  uint8_t old_pwd[SDMMC_BLOCK_MAX_PASSWORD_LENGTH]; /**< Old password */
  uint8_t new_pwd[SDMMC_BLOCK_MAX_PASSWORD_LENGTH]; /**< New password */
  uint8_t old_pwd_len; /**< Old password length */
  uint8_t new_pwd_len; /**< New password length. Set to 0 if password not set */
} SDMMC_BLOCK_PASSWORD_t;

/**
 * @brief Erase Address details.
 */
typedef struct SDMMC_BLOCK_ERASE_ADDRESS
{
  uint32_t start_address; /**< Erase Block Start Address */
  uint32_t end_address;   /**< Erase Block Start Address */
} SDMMC_BLOCK_ERASE_ADDRESS_t;

/* Anonymous structure/union guard start */
#if defined (__CC_ARM)
# pragma push
# pragma anon_unions
#elif defined (__TASKING__)
# pragma warning 586
#endif

/**
 * @brief SDMMC_BLOCK APP instance
 */
typedef struct SDMMC_BLOCK
{
  union
  {
#ifdef SDMMC_BLOCK_SPI
    SDMMC_BLOCK_SPI_t  *sdmmc_spi;   /**< SPI instance */
#endif

#ifdef SDMMC_BLOCK_SD
    SDMMC_BLOCK_SD_t *sdmmc_sd;      /**< SD instance */
#endif
  };

# ifdef SDMMC_BLOCK_CARD_WRITE_PROTECT_SIGNAL
  const SDMMC_BLOCK_PIN_CONFIG_t *sdwc;  /**< Card write protect signal */
# endif

#ifdef SDMMC_BLOCK_SPI

# ifdef SDMMC_BLOCK_SPI_CARD_LED_SIGNAL
  const SDMMC_BLOCK_PIN_CONFIG_t *led;  /**< LED signal, used in SPI mode */
# endif

#endif  /* SDMMC_BLOCK_SPI */

#if SDMMC_BLOCK_RTOS_MODE_SELECT
  CMSIS_RTOS_t *const cmsis_rtos;    /**< specific to RTOS mode */
#endif /* SDMMC_BLOCK_RTOS_MODE_SELECT */

  SDMMC_BLOCK_Config_Init init_pins; /**< Pins initialization function */
  uint8_t card_state;                /**< Card state */
  uint8_t card_type;                 /**< Card type */
  uint8_t card_capacity;             /**< Capacity of the card */
  SDMMC_BLOCK_RTOS_MODE_t rtos_mode; /**< RTOS mode */
  SDMMC_BLOCK_CARD_INTERFACE_t interface_mode; /**< Card interface mode */
  bool init_flag;                    /**< Flag indicating initialization return value */
} SDMMC_BLOCK_t;

/**
 * @}
 */

/* Anonymous structure/union guard end */
#if defined (__CC_ARM)
# pragma pop
#elif defined (__TASKING__)
# pragma warning restore
#endif

/* Support for C++ */
#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************************
 * API PROTOTYPES
 **********************************************************************************************************************/

/**
 * @ingroup SDMMC_BLOCK_apidoc
 * @{
 */

/**
 * @brief Get SDMMC_BLOCK APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 * <BR>
 * \par<b>Description:</b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 * This example gets the current version of the APP and checks for the major version to ensure that the APP is
 * compatible with DAVE-4.
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *
 *   status = DAVE_Init();    // SDMMC_BLOCK_Init() is called from DAVE_Init()
 *
 *   app_version = SDMMC_BLOCK_GetAppVersion();
 *
 *   if (app_version.major != 4U)
 *   {
 *     // Probably, not the right version.
 *   }
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t SDMMC_BLOCK_GetAppVersion(void);

/**
 * @brief  Initialize the the SDMMC_BLOCK APP with the configuration done in the GUI.
 * @param obj A pointer to SDMMC_BLOCK_t, pointing to the SDMMC_BLOCK handle configuration
 * @return SDMMC_BLOCK_STATUS_t: Status of SDMMC_BLOCK APP initialization.\n
 *                               SDMMC_BLOCK_STATUS_SUCCESS - on successful initialization.\n
 *                               SDMMC_BLOCK_STATUS_FAILURE - if initialization fails.\n
 *
 * \par<b>Description: </b><br>
 * <ul>
 * <li>Initialize the Host and port pins in case of the SD mode.</li>
 * <li>Initialize the SPI channel, ports (if selected) in case of SPI mode</li>
 * <li>If RTOS mode is selected, the RTOS is initialized</li>
 * </ul>
 *
 * Example Usage:
 * SDMMC_BLOCK_Init() function is called in DAVE_Init(). If SDMMC_BLOCK_Init() is not successful, other
 * functionalities are not supposed to be called.
 *
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *
 *   status = DAVE_Init();    // SDMMC_BLOCK_Init() is called from DAVE_Init()
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
SDMMC_BLOCK_STATUS_t SDMMC_BLOCK_Init(SDMMC_BLOCK_t *const obj);

/**
 * @brief Initialize the SD/MMC card and return the initialization status of the card
 * @param obj A pointer to SDMMC_BLOCK_t, pointing to the SDMMC_BLOCK handle configuration
 * @return SDMMC_BLOCK_STATUS_t: Status of SDMMC_BLOCK APP initialization.\n
 *                               SDMMC_BLOCK_STATUS_SUCCESS: on successful initialization.\n
 *                               SDMMC_BLOCK_STATUS_FAILURE: If initialization fails.\n
 *                               SDMMC_BLOCK_STATUS_NOTRDY : Card is not available or not initialized\n
 *
 * \par<b>Description: </b><br>
 * <ul>
 * <li>Initialize the card and update the card information like card type and card state. Initialization
 *     flag is set to 1 if the card is initialized properly. </li>
 * </ul>
 *
 * Example Usage:
 * This will initialize the card and update the card related properties and returns successful if card is
 * initialized successfully.
 *
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *   SDMMC_BLOCK_STATUS_t sdmmc_status;
 *
 *   status = DAVE_Init();    // SDMMC_BLOCK_Init() is called from DAVE_Init()
 *
 *   sdmmc_status = SDMMC_BLOCK_Initialize(&SDMMC_BLOCK_0);
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
SDMMC_BLOCK_STATUS_t SDMMC_BLOCK_Initialize(SDMMC_BLOCK_t *const obj);

/**
 * @brief Get the card's current status
 * @param obj A pointer to SDMMC_BLOCK_t, pointing to the SDMMC_BLOCK handle configuration
 * @return uint8_t \n
 *  *               SDMMC_BLOCK_CARD_STATE_INITIALIZED: If initialization is successful without any errors.\n
 *                  SDMMC_BLOCK_CARD_STATE_NOT_INITIALIZED: If initialization fails.\n
 *                  SDMMC_BLOCK_CARD_STATE_NO_CARD : Card is not available\n
 *                  SDMMC_BLOCK_CARD_STATE_WRITE_PROTECTED : Card is write protected\n
 *
 * \par<b>Description: </b><br>
 * Card state (initialization state, card availability and write protection state and the like)
 * is returned as a logically OR'd value indicating various states. The user may then use an
 * appropriate mask to take measures based on the states.
 *
 * Example Usage:
 * This will initialize the card. Post initialization, the current status of the card is requested.
 *
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *   uint8_t card_status;
 *
 *   status = DAVE_Init();    // SDMMC_BLOCK_Init() is called from DAVE_Init()
 *
 *   sdmmc_status = SDMMC_BLOCK_Initialize(&SDMMC_BLOCK_0);
 *
 *   card_status = SDMMC_BLOCK_GetStatus(&SDMMC_BLOCK_0);
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint8_t SDMMC_BLOCK_GetStatus(SDMMC_BLOCK_t *const obj);

/**
 * @brief Reads the specified number of blocks of data from the card
 * @param obj A pointer to SDMMC_BLOCK_t, pointing to the SDMMC_BLOCK handle configuration
 * @param read_buf Read aligned buffer pointer to store data read from the card.
 * @param sector_number Specifies the card sector address from which the read operation has to be started.
 * @param sector_count Specifies the number of sectors of data that has to be read (1 sector = 512 bytes)
 * @return SDMMC_BLOCK_STATUS_t: Status of SDMMC_BLOCK APP read operation.\n
 *                               SDMMC_BLOCK_STATUS_SUCCESS: on successful read operation.\n
 *                               SDMMC_BLOCK_STATUS_FAILURE: If read operation fails.\n
 *                               SDMMC_BLOCK_STATUS_NOTRDY : Card is not available or not initialized.\n
 *                               SDMMC_BLOCK_STATUS_LOCKED : Card is locked with password.\n
 *                               SDMMC_BLOCK_STATUS_WRPRT  : Card is write protected.\n
 * \par<b>Description: </b><br>
 * Block read can be single or multiple blocks. It is mandatory to pass an aligned buffer to store the data read
 * from the card.
 *
 * Example Usage:
 * This will initialize the card. If initialization is successful data will be written, read and then
 * erased from the card. Post these functions,  the card is finally ejected.
 *
 * @code
 * uint8_t send_data[1024];
 * uint8_t read_data[1024];
 * volatile uint32_t count;
 *
 * SDMMC_BLOCK_ERASE_ADDRESS_t erase_address =
 * {
 *  .start_address = 1004U,
 *  .end_address = 1005U
 * };
 *
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *   SDMMC_BLOCK_CARD_STATE_t card_status;
 *
 *   status = DAVE_Init();    // SDMMC_BLOCK_Init() is called from DAVE_Init()
 *
 *   sdmmc_status = SDMMC_BLOCK_Initialize(&SDMMC_BLOCK_0);
 *
 *   if (sdmmc_status == SDMMC_BLOCK_STATUS_SUCCESS)
 *   {
 *     do
 *     {
 *       send_data[count] = count;
 *     } while (count++ < 1024);
 *
 *     sdmmc_status = SDMMC_BLOCK_WriteBlock(&SDMMC_BLOCK_0, send_data, 1004U, 2U);
 *
 *     if (sdmmc_status == SDMMC_BLOCK_STATUS_SUCCESS)
 *     {
 *       sdmmc_status = SDMMC_BLOCK_ReadBlock(&SDMMC_BLOCK_0, read_data, 1004U, 2U);
 *
 *       for (count = 0; count < 1024; count++)
 *       {
 *         if(read_data[count] != send_data[count])
 *            status = DAVE_STATUS_FAILURE;
 *       }
 *
 *       sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_CTRL_TRIM, &erase_address);
 *
 *       sdmmc_status = SDMMC_BLOCK_ReadBlock(&SDMMC_BLOCK_0, read_data, 1004U, 2U);
 *
 *       for (count = 0; count < 1024; count++)
 *       {
 *         if(read_data[count] != 0U)
 *            status = DAVE_STATUS_FAILURE;
 *       }
 *     }
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_CTRL_EJECT, &buffer);
 *   }
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
SDMMC_BLOCK_STATUS_t SDMMC_BLOCK_ReadBlock(SDMMC_BLOCK_t *const obj,
                                           uint8_t *read_buf,
                                           const uint32_t sector_number,
                                           const uint8_t sector_count);

/**
 * @brief Write data blocks onto the card from the host system.
 * @param obj A pointer to SDMMC_BLOCK_t, pointing to the SDMMC_BLOCK handle configuration
 * @param write_buf Buffer pointer for the data to be stored into card.
 * @param sector_number Specifies the card sector address from which the write operation has to be started.
 * @param sector_count Specifies the number of sectors of data that has to be written. (1 sector = 512 bytes)
 * @return SDMMC_BLOCK_STATUS_t: Status of SDMMC_BLOCK APP write operation.\n
 *                               SDMMC_BLOCK_STATUS_SUCCESS: on successful read operation.\n
 *                               SDMMC_BLOCK_STATUS_FAILURE: If read operation fails.\n
 *                               SDMMC_BLOCK_STATUS_NOTRDY : Card is not available or not initialized\n
 *                               SDMMC_BLOCK_STATUS_LOCKED : Card is locked with password\n
 *                               SDMMC_BLOCK_STATUS_WRPRT  : Card is write protected.\n
 *
 * \par<b>Description: </b><br>
 * Write operation may be for single or multiple blocks.
 *
 * Example Usage:
 * This will initialize the card. If initialization is successful data will be written, read and then
 * erased from the card. Post these functions,  the card is finally ejected.
 *
 * @code
 * uint8_t send_data[1024];
 * uint8_t read_data[1024];
 * volatile uint32_t count;
 *
 * SDMMC_BLOCK_ERASE_ADDRESS_t erase_address =
 * {
 *  .start_address = 1004U,
 *  .end_address = 1005U
 * };
 *
 * #include <DAVE.h>
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t app_version;
 *   SDMMC_BLOCK_CARD_STATE_t card_status;
 *
 *   status = DAVE_Init();    // SDMMC_BLOCK_Init() is called from DAVE_Init()
 *
 *   sdmmc_status = SDMMC_BLOCK_Initialize(&SDMMC_BLOCK_0);
 *
 *   if (sdmmc_status == SDMMC_BLOCK_STATUS_SUCCESS)
 *   {
 *     do
 *     {
 *       send_data[count] = count;
 *     } while (count++ < 1024);
 *
 *     sdmmc_status = SDMMC_BLOCK_WriteBlock(&SDMMC_BLOCK_0, send_data, 1004U, 2U);
 *
 *     if (sdmmc_status == SDMMC_BLOCK_STATUS_SUCCESS)
 *     {
 *       sdmmc_status = SDMMC_BLOCK_ReadBlock(&SDMMC_BLOCK_0, read_data, 1004U, 2U);
 *
 *       for (count = 0; count < 1024; count++)
 *       {
 *         if(read_data[count] != send_data[count])
 *            status = DAVE_STATUS_FAILURE;
 *       }
 *
 *       sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_CTRL_TRIM, &erase_address);
 *
 *       sdmmc_status = SDMMC_BLOCK_ReadBlock(&SDMMC_BLOCK_0, read_data, 1004U, 2U);
 *
 *       for (count = 0; count < 1024; count++)
 *       {
 *         if(read_data[count] != 0U)
 *            status = DAVE_STATUS_FAILURE;
 *       }
 *     }
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_CTRL_EJECT, &buffer);
 *   }
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
SDMMC_BLOCK_STATUS_t SDMMC_BLOCK_WriteBlock(SDMMC_BLOCK_t *const obj,
                                            uint8_t *write_buf,
                                            const uint32_t sector_number,
                                            const uint8_t sector_count);

/**
 * @brief Control the specified SDMMC device features and the miscellaneous device independent functions
 *        other than disk read/write.
 * @param obj A pointer to SDMMC_BLOCK_t, pointing to the SDMMC_BLOCK handle configuration
 * @param command Specifies the command code.
 * @param buffer Pointer to the parameter buffer depends on the command code.\n
 *               When it is not used, specify a NULL pointer.
 * @return SDMMC_BLOCK_STATUS_t: Status of SDMMC_BLOCK APP operation.\n
 *                               SDMMC_BLOCK_STATUS_SUCCESS: on successful operation.\n
 *                               SDMMC_BLOCK_STATUS_FAILURE: If the specified operation fails.\n
 *                               SDMMC_BLOCK_STATUS_NOTRDY : Card is not available or not initialized\n
 *                               SDMMC_BLOCK_STATUS_LOCKED : Card is locked with password\n
 *                               SDMMC_BLOCK_STATUS_PARERR : If invalid parameter is passed as argument.\n
 *                               SDMMC_BLOCK_STATUS_WRPRT  : Card is write protected.\n
 *
 * \par<b>Description: </b><br>
 * For Locking features, the user must provide the password information in the SDMMC_BLOCK_PASSWORD_t structure.
 * <p>
 * <b>The IOCTL commands used are: </b>\n
 * Generic IOCTL commands \n
 *         SDMMC_BLOCK_CTRL_SYNC: Flush disk cache (for write functions) \n
 *         SDMMC_BLOCK_GET_SECTOR_COUNT: Get media size \n
 *         SDMMC_BLOCK_GET_SECTOR_SIZE: Get sector size \n
 *         SDMMC_BLOCK_GET_BLOCK_SIZE: Get erase block size \n
 *         SDMMC_BLOCK_CTRL_TRIM: Inform device that the data on the block of sectors is no longer used. \n
 *         SDMMC_BLOCK_CTRL_EJECT: Eject media \n
 * MMC/SD card specific IOCTL commands \n
 *         SDMMC_BLOCK_MMC_GET_TYPE: Get card type i.e. Standard Capacity v2/v1x or High Capacity card. \n
 *         SDMMC_BLOCK_MMC_GET_CSD: Get Card's Specific Data register \n
 *         SDMMC_BLOCK_MMC_GET_CID: Get Card's Identification Number \n
 *         SDMMC_BLOCK_MMC_GET_OCR: Get Card's Operating Condition Register  \n
 *         SDMMC_BLOCK_MMC_GET_SDSTAT:  Get SD bus status information.  \n
 *         SDMMC_BLOCK_MMC_LOCK_CARD: Locks the card. \n
 *         SDMMC_BLOCK_MMC_UNLOCK_CARD: Unlocks the card. \n
 *         SDMMC_BLOCK_MMC_SET_PASSWD: Set/replace the password. \n
 *         SDMMC_BLOCK_MMC_CLEAR_PASSWD: Clear the password. \n
 *         SDMMC_BLOCK_MMC_SET_LOCK: Sets the password and locks the card in the same power cycle. \n
 *         SDMMC_BLOCK_MMC_READ_LOCK_STATUS: Reads the current lock status of the card. \n
 *         SDMMC_BLOCK_MMC_FORCE_ERASE: Force erase the password. It is useful when user forgets the password. \n
 * </p>
 *
 * Example Usage1:
 * The example initializes the card. If initialization is successful the control then checks for the lock_status.
 * For a card without any password, the program should indicate that the card is not locked. Then a password of length
 * 6 is set and the card is locked with the configured password. The lock status is then checked to ensure that it is
 * locked. Post this operation, the card is unlocked. If the unlock operation is successful, the card should
 * indicate so. The password is then cleared.
 * @code
 * #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 * SDMMC_BLOCK_PASSWORD_t password =
 * {
 * .old_pwd_len = 6U,
 * .old_pwd = {'p', 'a', 's', 's', 'w', 'd'},
 * };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   SDMMC_BLOCK_STATUS_t sdmmc_status;
 *   SDMMC_BLOCK_CARD_LOCK_STATUS_t lock_status;
 *
 *   status = DAVE_Init();           // Initialization of DAVE APPs
 *
 *   sdmmc_status = SDMMC_BLOCK_Initialize(&SDMMC_BLOCK_0);
 *
 *   if  (sdmmc_status == SDMMC_BLOCK_STATUS_SUCCESS)
 *   {
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_READ_LOCK_STATUS, &lock_status);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_SET_PASSWD, &password);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_LOCK_CARD, &password);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_READ_LOCK_STATUS, &lock_status);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_UNLOCK_CARD, &password);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_READ_LOCK_STATUS, &lock_status);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_CLEAR_PASSWD, &password);
 *   }
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 *
 * Example Usage2:
 * This example demonstrates the procedure to change the existing password of the card and then performs a force erase
 * of the card.
 * @code
 * #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 * #include <string.h>
 * SDMMC_BLOCK_PASSWORD_t password =
 * {
 * .old_pwd_len = 6U,
 * .old_pwd = {'p', 'a', 's', 's', 'w', 'd'},
 * .new_pwd_len = 6U,
 * .new_pwd = {'s', 'e', 'c', 'r', 'e', 't'},
 * };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   SDMMC_BLOCK_STATUS_t sdmmc_status;
 *   SDMMC_BLOCK_CARD_LOCK_STATUS_t lock_status;
 *   uint8_t buffer;
 *
 *   status = DAVE_Init();           /. Initialization of DAVE APPs
 *
 *   sdmmc_status = SDMMC_BLOCK_Initialize(&SDMMC_BLOCK_0);
 *
 *   if (sdmmc_status == SDMMC_BLOCK_STATUS_SUCCESS)
 *   {
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_READ_LOCK_STATUS, &lock_status);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_SET_PASSWD, &password);
 *
 *     // Set the old password value with the new one. SO that card can be locked with the password configured.
 *     memcpy(password.old_pwd, password.new_pwd, password.new_pwd_len);
 *     password.old_pwd_len = password.new_pwd_len;
 *     password.new_pwd_len = 0U;
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_LOCK_CARD, &password);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_READ_LOCK_STATUS, &lock_status);
 *
 *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_FORCE_ERASE, &buffer);
 *   }
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     // Placeholder for error handler code. The while loop below can be replaced with an user error handler.
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *
 *   // Placeholder for user application code. The while loop below can be replaced with user application code.
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
SDMMC_BLOCK_STATUS_t SDMMC_BLOCK_Ioctl(SDMMC_BLOCK_t *const obj,
                                       const uint8_t command,
                                       void *buffer);

#if SDMMC_BLOCK_SD_CARD_DETECTION_SUPPORT

#ifdef SDMMC_BLOCK_SD

 /**
  * @brief Register a callback function
  * @param obj A pointer to SDMMC_BLOCK_t, pointing to the SDMMC_BLOCK handle configuration
  * @param cb A pointer to a function accepting ::SDMMC_BLOCK_SD_INTERRUPT_t and returning void
  * @return SDMMC_BLOCK_STATUS_t: Status of callback function registration.\n
  *                               SDMMC_BLOCK_STATUS_SUCCESS - On successful registration.\n
  *                               SDMMC_BLOCK_STATUS_PARERR - If registration fails (invalid callback parameter).\n
  * <BR>
  * \par<b>Description:</b><br>
  * The function can be used to register a callback function to signal a card detection
  * event. The microcontroller will generate interrupts for a card insertion and a card
  * removal event. The callback can be used to signal these events. The function shall
  * be invoked before invoking ::SDMMC_BLOCK_Initialize().
  *
  * Example Usage:
  * The following example registers a callback function for the card-detect events:
  * card insertion and removal.
  * @code
  * #include <DAVE.h>
  *
  * volatile bool led_status = false;
  *
  * void card_detect_callback(SDMMC_BLOCK_SD_INTERRUPT_t card_ins)
  * {
  *   if (card_ins == SDMMC_BLOCK_SD_INTERRUPT_CARD_INSERTION)
  *   {
  *     // Turn an LED on perhaps? Be sure to configure the LED first.
  *     led_status = true;
  *   }
  *   else
  *   {
  *     // Turn the LED off perhaps?
  *     led_status = false;
  *   }
  * }
  *
  * int main(void)
  * {
  *   DAVE_STATUS_t status;
  *   SDMMC_BLOCK_STATUS_t sdmmc_status;
  *   SDMMC_BLOCK_CARD_LOCK_STATUS_t lock_status;
  *
  *   status = DAVE_Init(); // SDMMC_BLOCK_Init() is called from DAVE_Init()
  *
  *   sdmmc_status = SDMMC_BLOCK_RegisterCallback(&SDMMC_BLOCK_0, card_detect_callback);
  *
  *   sdmmc_status = SDMMC_BLOCK_Initialize(&SDMMC_BLOCK_0);
  *   if (sdmmc_status == SDMMC_BLOCK_STATUS_SUCCESS)
  *   {
  *     sdmmc_status = SDMMC_BLOCK_Ioctl(&SDMMC_BLOCK_0, SDMMC_BLOCK_MMC_READ_LOCK_STATUS, &lock_status);
  *   }
  *
  *   // Placeholder for user application code.
  *   while(1U)
  *   {
  *   }
  * }
  * @endcode<BR>
  */
SDMMC_BLOCK_STATUS_t SDMMC_BLOCK_RegisterCallback(SDMMC_BLOCK_t *const obj,
                                                  void (*cb)(SDMMC_BLOCK_SD_INTERRUPT_t));

#endif /* #ifdef SDMMC_BLOCK_SD */

#endif /* #if SDMMC_BLOCK_SD_CARD_DETECTION_SUPPORT */

/**
 * @}
 */

/* Support for C++ */
#ifdef __cplusplus
}
#endif 

#include "sdmmc_block_extern.h"

#endif /* SDMMC_BLOCK_H */
